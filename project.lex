%{
/* list.tab.h was generated by bison with the -d option */
#include <stdlib.h>
#include "project.tab.h"
;
%}

%option noyywrap
%option yylineno

%x STAR_COMMENT

%%
"/*".*"*/"	{}
"/*"	{BEGIN(STAR_COMMENT);}
<STAR_COMMENT>. {}
<STAR_COMMENT>"*/" {BEGIN(0);}

[0-9]+     { yylval.sval = strdup(yytext); return NUM; }

[0-9]+'.'[0-9]* { yylval.sval = strdup(yytext); return NUM; }

"if"        {return IF;}
"else"        {return ELSE;}
"input"     {return INPUT;}
"output"     {return OUTPUT;}
"while"     {return WHILE;}
"switch"    {return SWITCH;}
"default"    {return DEFAULT;}
"break"    {return BREAK;}
"case"    {return CASE;}
"int"    {return INT;}
"float"    {return FLOAT;}

"("        { return '('; }
")"        { return ')'; }
"{"        { return '{'; }
"}"        { return '}'; }
","        { return ','; }
";"        { return ';'; }
":"        { return ':'; }
"="        { return '='; }
"*"        { yylval.ival = MUL_TYPE; return MULOP; }
"/"        { yylval.ival = DIV_TYPE; return MULOP; }
"+"        { yylval.ival = ADD_TYPE; return ADDOP; }
"-"        { yylval.ival = SUB_TYPE; return ADDOP; }

"<"        { yylval.ival = LT_TYPE; return RELOP; }
">"        { yylval.ival = GT_TYPE; return RELOP; }
"<="        { yylval.ival = LE_TYPE; return RELOP; }
">="        { yylval.ival = GE_TYPE; return RELOP; }
"!="        { yylval.ival = NEQ_TYPE; return RELOP; }
"=="        { yylval.ival = EQ_TYPE; return RELOP; }
"static_cast<int>"        { yylval.ival = CAST_INT_TYPE; return CAST; }
"static_cast<float>"        { yylval.ival = CAST_FLOAT_TYPE; return CAST; }
"!"        { return NOT; }
"||"        { return OR; }
"&&"        { return AND; }

[a-zA-Z][a-zA-Z0-9]* { yylval.sval = strdup(yytext); return ID; }

[\n\r\t ]+   /* skip white space */

"//".*     /* skip comment */

.          { fprintf (stderr, "line %d: unrecognized token %c\n", 
                               yylineno, yytext[0]); }

%%
